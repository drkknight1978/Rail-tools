<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Stamper - Railway Engineering Utilities</title>
    <link rel="stylesheet" href="railway-theme.css">
    <link rel="stylesheet" href="pdf-stamper.css">
    <style>
        /* PDF Stamper-specific overrides */
        .hidden {
            display: none;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .slider-value {
            text-align: right;
            font-size: 13px;
            color: #c9b896;
            font-weight: 500;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            cursor: pointer;
        }

        .checkbox-group label {
            margin: 0;
            cursor: pointer;
            color: #c9b896;
        }

        .logout-btn {
            background: linear-gradient(145deg, #8b4513 0%, #6b4423 100%);
        }

        .logout-btn:hover {
            background: linear-gradient(145deg, #a0522d 0%, #8b4513 100%);
        }
    </style>
    <!-- Authentication Script - MUST be loaded first -->
    <script src="auth.js"></script>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Utilities</a>

        <div class="header-controls">
            <h1>PDF Stamper</h1>
            <button class="logout-btn" onclick="RailwayAuth.logout()">Logout</button>
        </div>

        <div class="rivets-container">
            <span class="rivet"></span>
            <span class="rivet"></span>
            <span class="rivet"></span>
        </div>
        
        <!-- File Selection -->
        <div class="section">
            <h2>File Selection</h2>
            <div class="file-row">
                <label>PDF File:</label>
                <div class="file-path" id="pdfFileName">No file selected</div>
                <input type="file" id="pdfFile" accept=".pdf" class="hidden">
                <button class="btn" onclick="document.getElementById('pdfFile').click()">Browse...</button>
            </div>
            <div class="file-row">
                <label>Stamp Image:</label>
                <div class="file-path" id="stampFileName">No file selected</div>
                <input type="file" id="stampFile" accept="image/*" class="hidden">
                <button class="btn" onclick="document.getElementById('stampFile').click()">Browse...</button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="main-content">
            <!-- Preview Section -->
            <div class="preview-section">
                <h2>Preview</h2>
                <div class="preview-nav">
                    <button class="btn" id="prevPageBtn" disabled>Previous Page</button>
                    <span class="page-label" id="pageLabel">Page: 0 / 0</span>
                    <button class="btn" id="nextPageBtn" disabled>Next Page</button>
                </div>
                
                <div class="zoom-controls">
                    <label>Zoom:</label>
                    <button class="btn zoom-btn" id="zoomOutBtn" disabled>-</button>
                    <input type="range" id="zoomSlider" min="10" max="300" value="100" disabled class="slider">
                    <button class="btn zoom-btn" id="zoomInBtn" disabled>+</button>
                    <span class="zoom-label" id="zoomLabel">100%</span>
                    <button class="btn btn-secondary" id="zoomFitBtn" disabled>Fit</button>
                </div>

                <div class="preview-container" id="previewContainer">
                    <canvas id="previewCanvas"></canvas>
                </div>
            </div>

            <!-- Controls Section -->
            <div class="controls-section">
                <!-- Position Controls -->
                <div class="control-group">
                    <h3>Stamp Controls</h3>
                    
                    <div class="control-item">
                        <label>Position Preset:</label>
                        <select id="positionPreset" disabled>
                            <option value="top-left">Top-Left</option>
                            <option value="top-right">Top-Right</option>
                            <option value="center">Center</option>
                            <option value="bottom-left">Bottom-Left</option>
                            <option value="bottom-right">Bottom-Right</option>
                            <option value="custom">Custom</option>
                        </select>
                    </div>

                    <div class="control-item">
                        <label>Coordinates:</label>
                        <div class="coord-inputs">
                            <div>
                                <label>X:</label>
                                <input type="number" id="xCoord" value="0" min="0" disabled>
                            </div>
                            <div>
                                <label>Y:</label>
                                <input type="number" id="yCoord" value="0" min="0" disabled>
                            </div>
                        </div>
                    </div>

                    <div class="control-item">
                        <label>Opacity:</label>
                        <div class="slider-container">
                            <input type="range" id="opacitySlider" min="0" max="100" value="100" disabled>
                            <div class="slider-value" id="opacityValue">100%</div>
                        </div>
                    </div>

                    <div class="control-item">
                        <label>Scale:</label>
                        <div class="slider-container">
                            <input type="range" id="scaleSlider" min="10" max="200" value="100" disabled>
                            <div class="slider-value" id="scaleValue">100%</div>
                        </div>
                    </div>
                </div>

                <!-- Date Controls -->
                <div class="control-group">
                    <h3>Date Options</h3>

                    <div class="checkbox-group">
                        <input type="checkbox" id="addDateCheck" disabled>
                        <label for="addDateCheck">Add date to stamp</label>
                    </div>

                    <div class="control-item">
                        <label>Date Position:</label>
                        <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 8px;">
                            <div class="checkbox-group">
                                <input type="radio" id="datePositionMiddle" name="datePosition" value="middle" checked disabled>
                                <label for="datePositionMiddle">Middle (center of stamp)</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="radio" id="datePositionTop" name="datePosition" value="top" disabled>
                                <label for="datePositionTop">Top (above stamp)</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="radio" id="datePositionBottom" name="datePosition" value="bottom" disabled>
                                <label for="datePositionBottom">Bottom (below stamp)</label>
                            </div>
                        </div>
                    </div>

                    <div class="control-item">
                        <label>Date:</label>
                        <input type="date" id="dateInput" disabled>
                    </div>

                    <div class="control-item">
                        <label>Date Color:</label>
                        <input type="color" id="dateColor" value="#0000ff" disabled>
                    </div>

                    <div class="control-item">
                        <label>Font Size:</label>
                        <div class="slider-container">
                            <input type="range" id="dateFontSizeSlider" min="8" max="72" value="24" disabled>
                            <div class="slider-value" id="dateFontSizeValue">24px</div>
                        </div>
                    </div>

                    <div class="control-item">
                        <label>Date Position Adjustment:</label>
                        <div style="display: grid; grid-template-columns: auto 1fr; gap: 10px; margin-top: 8px;">
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <label style="margin: 0; min-width: 15px;">X:</label>
                                <button class="btn zoom-btn" id="dateXMinus10" disabled>−10</button>
                                <button class="btn zoom-btn" id="dateXMinus1" disabled>−1</button>
                                <span style="min-width: 40px; text-align: center; color: #c9b896;" id="dateOffsetXValue">0</span>
                                <button class="btn zoom-btn" id="dateXPlus1" disabled>+1</button>
                                <button class="btn zoom-btn" id="dateXPlus10" disabled>+10</button>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <label style="margin: 0; min-width: 15px;">Y:</label>
                                <button class="btn zoom-btn" id="dateYMinus10" disabled>−10</button>
                                <button class="btn zoom-btn" id="dateYMinus1" disabled>−1</button>
                                <span style="min-width: 40px; text-align: center; color: #c9b896;" id="dateOffsetYValue">0</span>
                                <button class="btn zoom-btn" id="dateYPlus1" disabled>+1</button>
                                <button class="btn zoom-btn" id="dateYPlus10" disabled>+10</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Page Range Controls -->
                <div class="control-group">
                    <h3>Page Options</h3>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="allPagesCheck" disabled>
                        <label for="allPagesCheck">Apply to all pages</label>
                    </div>

                    <div class="control-item">
                        <label>Page Range:</label>
                        <input type="text" id="pageRangeInput" placeholder="e.g., 1-3, 5, 7-9" disabled>
                        <div class="info-text">Leave empty for current page only</div>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="batchModeCheck" disabled>
                        <label for="batchModeCheck">Batch mode (multiple PDFs)</label>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="control-group">
                    <h3>Actions</h3>
                    <div class="action-buttons">
                        <button class="btn btn-success" id="processBtn" disabled>Process & Download</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Include PDF.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    
    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Application state
        const state = {
            pdfFile: null,
            stampFile: null,
            pdfDocument: null,
            currentPage: 0,
            stampImage: null,
            stampPosition: { x: 0, y: 0 },
            opacity: 1.0,
            zoomFactor: 1.0,
            stampScale: 1.0,
            originalStampSize: null,
            isDragging: false,
            dragStart: null,
            dragStartStampPos: null,
            renderedPage: null,
            originalPageWidth: 0,
            originalPageHeight: 0,
            // Date options
            addDate: false,
            datePosition: 'middle',
            dateValue: new Date().toISOString().split('T')[0],
            dateColor: '#0000ff',
            dateFontSize: 24,
            dateOffsetX: 0,
            dateOffsetY: 0
        };

        // DOM elements
        const elements = {
            pdfFile: document.getElementById('pdfFile'),
            stampFile: document.getElementById('stampFile'),
            pdfFileName: document.getElementById('pdfFileName'),
            stampFileName: document.getElementById('stampFileName'),
            prevPageBtn: document.getElementById('prevPageBtn'),
            nextPageBtn: document.getElementById('nextPageBtn'),
            pageLabel: document.getElementById('pageLabel'),
            zoomSlider: document.getElementById('zoomSlider'),
            zoomInBtn: document.getElementById('zoomInBtn'),
            zoomOutBtn: document.getElementById('zoomOutBtn'),
            zoomFitBtn: document.getElementById('zoomFitBtn'),
            zoomLabel: document.getElementById('zoomLabel'),
            previewCanvas: document.getElementById('previewCanvas'),
            previewContainer: document.getElementById('previewContainer'),
            positionPreset: document.getElementById('positionPreset'),
            xCoord: document.getElementById('xCoord'),
            yCoord: document.getElementById('yCoord'),
            opacitySlider: document.getElementById('opacitySlider'),
            opacityValue: document.getElementById('opacityValue'),
            scaleSlider: document.getElementById('scaleSlider'),
            scaleValue: document.getElementById('scaleValue'),
            allPagesCheck: document.getElementById('allPagesCheck'),
            pageRangeInput: document.getElementById('pageRangeInput'),
            batchModeCheck: document.getElementById('batchModeCheck'),
            processBtn: document.getElementById('processBtn'),
            // Date elements
            addDateCheck: document.getElementById('addDateCheck'),
            datePositionMiddle: document.getElementById('datePositionMiddle'),
            datePositionTop: document.getElementById('datePositionTop'),
            datePositionBottom: document.getElementById('datePositionBottom'),
            dateInput: document.getElementById('dateInput'),
            dateColor: document.getElementById('dateColor'),
            dateFontSizeSlider: document.getElementById('dateFontSizeSlider'),
            dateFontSizeValue: document.getElementById('dateFontSizeValue'),
            dateXMinus10: document.getElementById('dateXMinus10'),
            dateXMinus1: document.getElementById('dateXMinus1'),
            dateXPlus1: document.getElementById('dateXPlus1'),
            dateXPlus10: document.getElementById('dateXPlus10'),
            dateYMinus10: document.getElementById('dateYMinus10'),
            dateYMinus1: document.getElementById('dateYMinus1'),
            dateYPlus1: document.getElementById('dateYPlus1'),
            dateYPlus10: document.getElementById('dateYPlus10'),
            dateOffsetXValue: document.getElementById('dateOffsetXValue'),
            dateOffsetYValue: document.getElementById('dateOffsetYValue')
        };

        // Event Listeners - File Selection
        elements.pdfFile.addEventListener('change', handlePdfFileSelect);
        elements.stampFile.addEventListener('change', handleStampFileSelect);

        // Event Listeners - Navigation
        elements.prevPageBtn.addEventListener('click', previousPage);
        elements.nextPageBtn.addEventListener('click', nextPage);

        // Event Listeners - Zoom
        elements.zoomSlider.addEventListener('input', handleZoomChange);
        elements.zoomInBtn.addEventListener('click', () => zoomBy(10));
        elements.zoomOutBtn.addEventListener('click', () => zoomBy(-10));
        elements.zoomFitBtn.addEventListener('click', zoomToFit);

        // Event Listeners - Controls
        elements.positionPreset.addEventListener('change', handlePositionPresetChange);
        elements.xCoord.addEventListener('input', handleCoordChange);
        elements.yCoord.addEventListener('input', handleCoordChange);
        elements.opacitySlider.addEventListener('input', handleOpacityChange);
        elements.scaleSlider.addEventListener('input', handleScaleChange);
        elements.allPagesCheck.addEventListener('change', updateUIState);
        elements.processBtn.addEventListener('click', handleProcess);

        // Event Listeners - Date Controls
        elements.addDateCheck.addEventListener('change', handleAddDateChange);
        elements.datePositionMiddle.addEventListener('change', handleDatePositionChange);
        elements.datePositionTop.addEventListener('change', handleDatePositionChange);
        elements.datePositionBottom.addEventListener('change', handleDatePositionChange);
        elements.dateInput.addEventListener('change', handleDateInputChange);
        elements.dateColor.addEventListener('input', handleDateColorChange);
        elements.dateFontSizeSlider.addEventListener('input', handleDateFontSizeChange);
        elements.dateXMinus10.addEventListener('click', () => adjustDateOffset('x', -10));
        elements.dateXMinus1.addEventListener('click', () => adjustDateOffset('x', -1));
        elements.dateXPlus1.addEventListener('click', () => adjustDateOffset('x', 1));
        elements.dateXPlus10.addEventListener('click', () => adjustDateOffset('x', 10));
        elements.dateYMinus10.addEventListener('click', () => adjustDateOffset('y', -10));
        elements.dateYMinus1.addEventListener('click', () => adjustDateOffset('y', -1));
        elements.dateYPlus1.addEventListener('click', () => adjustDateOffset('y', 1));
        elements.dateYPlus10.addEventListener('click', () => adjustDateOffset('y', 10));

        // Event Listeners - Canvas Dragging
        elements.previewCanvas.addEventListener('mousedown', handleMouseDown);
        elements.previewCanvas.addEventListener('mousemove', handleMouseMove);
        elements.previewCanvas.addEventListener('mouseup', handleMouseUp);
        elements.previewCanvas.addEventListener('mouseleave', handleMouseUp);

        // File Selection Handlers
        async function handlePdfFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            state.pdfFile = file;
            elements.pdfFileName.textContent = file.name + ' (loading...)';
            elements.pdfFileName.style.color = '#666';

            try {
                const arrayBuffer = await file.arrayBuffer();
                const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                state.pdfDocument = await loadingTask.promise;
                state.currentPage = 0;
                
                console.log('PDF loaded:', state.pdfDocument.numPages, 'pages');
                elements.pdfFileName.textContent = file.name + ' ✓ (' + state.pdfDocument.numPages + ' pages)';
                elements.pdfFileName.style.color = '#28a745';
                
                await renderPage();
                updateUIState();
            } catch (error) {
                alert('Error loading PDF: ' + error.message);
                elements.pdfFileName.textContent = file.name + ' ✗ (failed)';
                elements.pdfFileName.style.color = '#dc3545';
                console.error('PDF load error:', error);
            }
        }

        async function handleStampFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            state.stampFile = file;
            elements.stampFileName.textContent = file.name + ' (loading...)';
            elements.stampFileName.style.color = '#666';

            try {
                const img = new Image();
                img.src = URL.createObjectURL(file);
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                });
                
                state.stampImage = img;
                state.originalStampSize = { width: img.width, height: img.height };
                
                console.log('Stamp loaded:', state.originalStampSize);
                elements.stampFileName.textContent = file.name + ' ✓ (' + img.width + 'x' + img.height + ')';
                elements.stampFileName.style.color = '#28a745';
                
                if (state.renderedPage) {
                    handlePositionPresetChange();
                    updatePreview();
                } else if (state.pdfDocument) {
                    // PDF is loaded but page hasn't rendered yet, wait a bit
                    setTimeout(() => {
                        if (state.renderedPage) {
                            handlePositionPresetChange();
                            updatePreview();
                        }
                    }, 100);
                }
                updateUIState();
            } catch (error) {
                alert('Error loading stamp: ' + error.message);
                elements.stampFileName.textContent = file.name + ' ✗ (failed)';
                elements.stampFileName.style.color = '#dc3545';
                console.error('Stamp load error:', error);
            }
        }

        // Page Navigation
        async function previousPage() {
            if (state.currentPage > 0) {
                state.currentPage--;
                await renderPage();
            }
        }

        async function nextPage() {
            if (state.currentPage < state.pdfDocument.numPages - 1) {
                state.currentPage++;
                await renderPage();
            }
        }

        // Rendering
        async function renderPage() {
            if (!state.pdfDocument) return;

            const page = await state.pdfDocument.getPage(state.currentPage + 1);
            const viewport = page.getViewport({ scale: 2.0 }); // Render at 2x for quality

            state.originalPageWidth = viewport.width;
            state.originalPageHeight = viewport.height;

            // Create an offscreen canvas for the PDF
            const offscreenCanvas = document.createElement('canvas');
            const context = offscreenCanvas.getContext('2d');
            offscreenCanvas.width = viewport.width;
            offscreenCanvas.height = viewport.height;

            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;

            state.renderedPage = offscreenCanvas;
            
            elements.pageLabel.textContent = `Page: ${state.currentPage + 1} / ${state.pdfDocument.numPages}`;
            
            handlePositionPresetChange();
            updatePreview();
            
            // Auto-fit on first load
            if (state.zoomFactor === 1.0) {
                setTimeout(zoomToFit, 100);
            }
        }

        function updatePreview() {
            if (!state.renderedPage) {
                console.log('No rendered page yet');
                return;
            }

            const canvas = elements.previewCanvas;
            const ctx = canvas.getContext('2d');

            // Calculate zoomed dimensions
            const zoomedWidth = state.originalPageWidth * state.zoomFactor;
            const zoomedHeight = state.originalPageHeight * state.zoomFactor;

            canvas.width = zoomedWidth;
            canvas.height = zoomedHeight;

            // Draw PDF (zoomed)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(state.renderedPage, 0, 0, zoomedWidth, zoomedHeight);

            // Draw stamp if loaded
            if (state.stampImage && state.originalStampSize) {
                const scaledStampWidth = state.originalStampSize.width * state.stampScale;
                const scaledStampHeight = state.originalStampSize.height * state.stampScale;

                const zoomedX = state.stampPosition.x * state.zoomFactor;
                const zoomedY = state.stampPosition.y * state.zoomFactor;
                const zoomedStampWidth = scaledStampWidth * state.zoomFactor;
                const zoomedStampHeight = scaledStampHeight * state.zoomFactor;

                console.log('Drawing stamp at:', {
                    x: zoomedX,
                    y: zoomedY,
                    width: zoomedStampWidth,
                    height: zoomedStampHeight,
                    opacity: state.opacity
                });

                ctx.globalAlpha = state.opacity;
                ctx.drawImage(
                    state.stampImage,
                    zoomedX,
                    zoomedY,
                    zoomedStampWidth,
                    zoomedStampHeight
                );
                ctx.globalAlpha = 1.0;

                // Draw date if enabled
                if (state.addDate && state.dateValue) {
                    const fontSize = state.dateFontSize * state.zoomFactor;
                    ctx.font = `${fontSize}px Arial`;
                    ctx.fillStyle = state.dateColor;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    const dateText = new Date(state.dateValue).toLocaleDateString();
                    let dateX, dateY;

                    if (state.datePosition === 'middle') {
                        // Center of stamp
                        dateX = zoomedX + (zoomedStampWidth * 0.5);
                        dateY = zoomedY + (zoomedStampHeight * 0.5);
                    } else if (state.datePosition === 'top') {
                        // Above stamp, centered
                        dateX = zoomedX + (zoomedStampWidth * 0.5);
                        dateY = zoomedY - (fontSize * 0.6);
                    } else if (state.datePosition === 'bottom') {
                        // Below stamp, centered
                        dateX = zoomedX + (zoomedStampWidth * 0.5);
                        dateY = zoomedY + zoomedStampHeight + (fontSize * 0.6);
                    }

                    // Apply offset
                    dateX += state.dateOffsetX * state.zoomFactor;
                    dateY += state.dateOffsetY * state.zoomFactor;

                    ctx.fillText(dateText, dateX, dateY);
                }
            } else {
                if (!state.stampImage) {
                    console.log('No stamp image loaded');
                }
                if (!state.originalStampSize) {
                    console.log('No original stamp size stored');
                }
            }
        }

        // Zoom Controls
        function handleZoomChange(e) {
            state.zoomFactor = e.target.value / 100;
            elements.zoomLabel.textContent = `${e.target.value}%`;
            updatePreview();
        }

        function zoomBy(delta) {
            const newValue = Math.max(10, Math.min(300, parseInt(elements.zoomSlider.value) + delta));
            elements.zoomSlider.value = newValue;
            handleZoomChange({ target: elements.zoomSlider });
        }

        function zoomToFit() {
            if (!state.renderedPage) return;

            const containerWidth = elements.previewContainer.clientWidth;
            const containerHeight = elements.previewContainer.clientHeight;
            
            const scaleX = containerWidth / state.originalPageWidth;
            const scaleY = containerHeight / state.originalPageHeight;
            const scale = Math.min(scaleX, scaleY) * 0.95;

            elements.zoomSlider.value = Math.round(scale * 100);
            handleZoomChange({ target: elements.zoomSlider });
        }

        // Position Controls
        function handlePositionPresetChange() {
            if (!state.renderedPage || !state.stampImage) {
                console.log('Cannot set position - missing:', {
                    hasRenderedPage: !!state.renderedPage,
                    hasStampImage: !!state.stampImage
                });
                return;
            }

            const preset = elements.positionPreset.value;
            const pw = state.originalPageWidth;
            const ph = state.originalPageHeight;
            const sw = state.originalStampSize.width * state.stampScale;
            const sh = state.originalStampSize.height * state.stampScale;

            let x, y;

            switch (preset) {
                case 'top-left':
                    x = 0; y = 0;
                    break;
                case 'top-right':
                    x = pw - sw; y = 0;
                    break;
                case 'center':
                    x = (pw - sw) / 2; y = (ph - sh) / 2;
                    break;
                case 'bottom-left':
                    x = 0; y = ph - sh;
                    break;
                case 'bottom-right':
                    x = pw - sw; y = ph - sh;
                    break;
                case 'custom':
                    x = state.stampPosition.x;
                    y = state.stampPosition.y;
                    break;
            }

            x = Math.max(0, Math.min(pw - sw, x));
            y = Math.max(0, Math.min(ph - sh, y));

            state.stampPosition = { x, y };
            elements.xCoord.value = Math.round(x);
            elements.yCoord.value = Math.round(y);
            elements.xCoord.max = Math.max(0, pw - sw);
            elements.yCoord.max = Math.max(0, ph - sh);

            console.log('Position set:', { preset, x, y, pw, ph, sw, sh });

            updatePreview();
        }

        function handleCoordChange() {
            state.stampPosition.x = parseInt(elements.xCoord.value) || 0;
            state.stampPosition.y = parseInt(elements.yCoord.value) || 0;
            
            if (elements.positionPreset.value !== 'custom') {
                elements.positionPreset.value = 'custom';
            }
            
            updatePreview();
        }

        function handleOpacityChange(e) {
            state.opacity = e.target.value / 100;
            elements.opacityValue.textContent = `${e.target.value}%`;
            updatePreview();
        }

        function handleScaleChange(e) {
            state.stampScale = e.target.value / 100;
            elements.scaleValue.textContent = `${e.target.value}%`;
            handlePositionPresetChange();
        }

        // Date Control Handlers
        function handleAddDateChange(e) {
            state.addDate = e.target.checked;
            updateUIState();
            updatePreview();
        }

        function handleDatePositionChange(e) {
            state.datePosition = e.target.value;
            updatePreview();
        }

        function handleDateInputChange(e) {
            state.dateValue = e.target.value;
            updatePreview();
        }

        function handleDateColorChange(e) {
            state.dateColor = e.target.value;
            updatePreview();
        }

        function handleDateFontSizeChange(e) {
            state.dateFontSize = parseInt(e.target.value);
            elements.dateFontSizeValue.textContent = `${e.target.value}px`;
            updatePreview();
        }

        function adjustDateOffset(axis, delta) {
            if (axis === 'x') {
                state.dateOffsetX += delta;
                elements.dateOffsetXValue.textContent = state.dateOffsetX;
            } else if (axis === 'y') {
                state.dateOffsetY += delta;
                elements.dateOffsetYValue.textContent = state.dateOffsetY;
            }
            updatePreview();
        }

        // Mouse Dragging
        function handleMouseDown(e) {
            if (!state.stampImage) return;

            const rect = elements.previewCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const scaledStampWidth = state.originalStampSize.width * state.stampScale;
            const scaledStampHeight = state.originalStampSize.height * state.stampScale;
            const zoomedX = state.stampPosition.x * state.zoomFactor;
            const zoomedY = state.stampPosition.y * state.zoomFactor;
            const zoomedStampWidth = scaledStampWidth * state.zoomFactor;
            const zoomedStampHeight = scaledStampHeight * state.zoomFactor;

            // Check if click is within stamp bounds
            if (mouseX >= zoomedX && mouseX <= zoomedX + zoomedStampWidth &&
                mouseY >= zoomedY && mouseY <= zoomedY + zoomedStampHeight) {
                state.isDragging = true;
                state.dragStart = { x: mouseX, y: mouseY };
                state.dragStartStampPos = { ...state.stampPosition };
                elements.previewCanvas.classList.add('dragging');
            }
        }

        function handleMouseMove(e) {
            if (!state.isDragging) return;

            const rect = elements.previewCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const deltaX = (mouseX - state.dragStart.x) / state.zoomFactor;
            const deltaY = (mouseY - state.dragStart.y) / state.zoomFactor;

            const scaledStampWidth = state.originalStampSize.width * state.stampScale;
            const scaledStampHeight = state.originalStampSize.height * state.stampScale;

            let newX = state.dragStartStampPos.x + deltaX;
            let newY = state.dragStartStampPos.y + deltaY;

            // Clamp to bounds
            newX = Math.max(0, Math.min(state.originalPageWidth - scaledStampWidth, newX));
            newY = Math.max(0, Math.min(state.originalPageHeight - scaledStampHeight, newY));

            state.stampPosition = { x: newX, y: newY };
            elements.xCoord.value = Math.round(newX);
            elements.yCoord.value = Math.round(newY);
            
            if (elements.positionPreset.value !== 'custom') {
                elements.positionPreset.value = 'custom';
            }

            updatePreview();
        }

        function handleMouseUp() {
            if (state.isDragging) {
                state.isDragging = false;
                elements.previewCanvas.classList.remove('dragging');
            }
        }

        // Process and Download
        async function handleProcess() {
            if (!state.pdfFile || !state.stampFile) {
                alert('Please select both a PDF and a stamp image.');
                return;
            }

            try {
                elements.processBtn.disabled = true;
                elements.processBtn.textContent = 'Processing...';

                // Load the PDF with pdf-lib
                const pdfBytes = await state.pdfFile.arrayBuffer();
                const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);

                // Convert stamp to PNG bytes
                const stampCanvas = document.createElement('canvas');
                const stampCtx = stampCanvas.getContext('2d');
                
                const scaledWidth = Math.round(state.originalStampSize.width * state.stampScale);
                const scaledHeight = Math.round(state.originalStampSize.height * state.stampScale);
                
                stampCanvas.width = scaledWidth;
                stampCanvas.height = scaledHeight;
                
                stampCtx.globalAlpha = state.opacity;
                stampCtx.drawImage(state.stampImage, 0, 0, scaledWidth, scaledHeight);
                
                const stampBlob = await new Promise(resolve => 
                    stampCanvas.toBlob(resolve, 'image/png')
                );
                const stampBytes = await stampBlob.arrayBuffer();
                const stampImage = await pdfDoc.embedPng(stampBytes);

                // Determine which pages to stamp
                let pagesToStamp = [];
                if (elements.allPagesCheck.checked) {
                    pagesToStamp = Array.from({ length: pdfDoc.getPageCount() }, (_, i) => i);
                } else {
                    const rangeText = elements.pageRangeInput.value.trim();
                    if (rangeText) {
                        pagesToStamp = parsePageRange(rangeText, pdfDoc.getPageCount());
                    } else {
                        pagesToStamp = [state.currentPage];
                    }
                }

                // Get preview dimensions for scaling
                const previewWidth = state.originalPageWidth;
                const previewHeight = state.originalPageHeight;

                // Stamp each page
                for (const pageIndex of pagesToStamp) {
                    const page = pdfDoc.getPage(pageIndex);
                    const { width: pdfWidth, height: pdfHeight } = page.getSize();

                    // Calculate scaling factors
                    const scaleX = pdfWidth / previewWidth;
                    const scaleY = pdfHeight / previewHeight;

                    // Scale position and size
                    const x = state.stampPosition.x * scaleX;
                    const y = pdfHeight - (state.stampPosition.y * scaleY) - (scaledHeight * scaleY);
                    const width = scaledWidth * scaleX;
                    const height = scaledHeight * scaleY;

                    page.drawImage(stampImage, {
                        x: x,
                        y: y,
                        width: width,
                        height: height,
                        opacity: state.opacity
                    });

                    // Draw date text if enabled
                    if (state.addDate && state.dateValue) {
                        const dateText = new Date(state.dateValue).toLocaleDateString();
                        const fontSize = state.dateFontSize * scaleX;

                        // Convert hex color to RGB
                        const hexToRgb = (hex) => {
                            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                            return result ? {
                                r: parseInt(result[1], 16) / 255,
                                g: parseInt(result[2], 16) / 255,
                                b: parseInt(result[3], 16) / 255
                            } : { r: 0, g: 0, b: 1 };
                        };

                        const rgb = hexToRgb(state.dateColor);

                        // Measure text width for centering
                        const textWidth = (dateText.length * fontSize) / 2; // Approximate

                        let dateX, dateY;

                        if (state.datePosition === 'middle') {
                            // Center of stamp
                            dateX = x + (width * 0.5) - (textWidth / 2);
                            dateY = pdfHeight - (state.stampPosition.y * scaleY) - (scaledHeight * scaleY * 0.5) - (fontSize * 0.3);
                        } else if (state.datePosition === 'top') {
                            // Above stamp
                            dateX = x + (width * 0.5) - (textWidth / 2);
                            dateY = pdfHeight - (state.stampPosition.y * scaleY) + fontSize;
                        } else if (state.datePosition === 'bottom') {
                            // Below stamp
                            dateX = x + (width * 0.5) - (textWidth / 2);
                            dateY = pdfHeight - (state.stampPosition.y * scaleY) - (scaledHeight * scaleY) - fontSize;
                        }

                        // Apply offset
                        dateX += state.dateOffsetX * scaleX;
                        dateY -= state.dateOffsetY * scaleY; // Y is inverted in PDF coordinates

                        page.drawText(dateText, {
                            x: dateX,
                            y: dateY,
                            size: fontSize,
                            color: PDFLib.rgb(rgb.r, rgb.g, rgb.b)
                        });
                    }
                }

                // Save and download
                const modifiedPdfBytes = await pdfDoc.save();
                const blob = new Blob([modifiedPdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'stamped_' + state.pdfFile.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert('PDF processed and downloaded successfully!');
            } catch (error) {
                alert('Error processing PDF: ' + error.message);
                console.error(error);
            } finally {
                elements.processBtn.disabled = false;
                elements.processBtn.textContent = 'Process & Download';
            }
        }

        function parsePageRange(rangeText, totalPages) {
            const pages = [];
            const parts = rangeText.split(',');

            for (const part of parts) {
                const trimmed = part.trim();
                if (trimmed.includes('-')) {
                    const [start, end] = trimmed.split('-').map(s => s.trim());
                    const startPage = start ? parseInt(start) - 1 : 0;
                    const endPage = end ? parseInt(end) - 1 : totalPages - 1;
                    
                    for (let i = startPage; i <= endPage && i < totalPages; i++) {
                        if (i >= 0 && !pages.includes(i)) {
                            pages.push(i);
                        }
                    }
                } else if (trimmed) {
                    const pageNum = parseInt(trimmed) - 1;
                    if (pageNum >= 0 && pageNum < totalPages && !pages.includes(pageNum)) {
                        pages.push(pageNum);
                    }
                }
            }

            return pages.sort((a, b) => a - b);
        }

        // UI State Management
        function updateUIState() {
            const hasPdf = !!state.pdfDocument;
            const hasStamp = !!state.stampImage;
            const ready = hasPdf && hasStamp;

            elements.prevPageBtn.disabled = !hasPdf || state.currentPage === 0;
            elements.nextPageBtn.disabled = !hasPdf || state.currentPage >= state.pdfDocument?.numPages - 1;
            elements.zoomSlider.disabled = !hasPdf;
            elements.zoomInBtn.disabled = !hasPdf;
            elements.zoomOutBtn.disabled = !hasPdf;
            elements.zoomFitBtn.disabled = !hasPdf;
            elements.positionPreset.disabled = !ready;
            elements.xCoord.disabled = !ready;
            elements.yCoord.disabled = !ready;
            elements.opacitySlider.disabled = !ready;
            elements.scaleSlider.disabled = !ready;
            elements.allPagesCheck.disabled = !ready;
            elements.pageRangeInput.disabled = !ready || elements.allPagesCheck.checked;
            elements.batchModeCheck.disabled = !ready;
            elements.processBtn.disabled = !ready;

            // Date controls
            elements.addDateCheck.disabled = !ready;
            const dateEnabled = ready && state.addDate;
            elements.datePositionMiddle.disabled = !dateEnabled;
            elements.datePositionTop.disabled = !dateEnabled;
            elements.datePositionBottom.disabled = !dateEnabled;
            elements.dateInput.disabled = !dateEnabled;
            elements.dateColor.disabled = !dateEnabled;
            elements.dateFontSizeSlider.disabled = !dateEnabled;
            elements.dateXMinus10.disabled = !dateEnabled;
            elements.dateXMinus1.disabled = !dateEnabled;
            elements.dateXPlus1.disabled = !dateEnabled;
            elements.dateXPlus10.disabled = !dateEnabled;
            elements.dateYMinus10.disabled = !dateEnabled;
            elements.dateYMinus1.disabled = !dateEnabled;
            elements.dateYPlus1.disabled = !dateEnabled;
            elements.dateYPlus10.disabled = !dateEnabled;
        }

        // Initialize
        elements.dateInput.value = state.dateValue;
        updateUIState();
    </script>
</body>
</html>
