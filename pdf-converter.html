<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF to TIFF Converter - Railway Engineering Utilities</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e8d5b5;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #8b6f47;
            position: relative;
        }

        .header::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 3px;
            background: #b8860b;
        }

        .header h1 {
            font-size: 2.5em;
            color: #d4af37;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
            letter-spacing: 2px;
            font-variant: small-caps;
        }

        .header p {
            color: #b8945f;
            font-style: italic;
            letter-spacing: 1px;
        }

        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 8px 20px;
            background: linear-gradient(145deg, #8b4513 0%, #6b4423 100%);
            color: #f5e6d3;
            text-decoration: none;
            border: 1px solid #5a4632;
            border-radius: 4px;
            font-size: 13px;
            font-weight: bold;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .back-link:hover {
            background: linear-gradient(145deg, #a0522d 0%, #8b4513 100%);
            box-shadow: 0 4px 12px rgba(139, 69, 19, 0.4);
        }

        .main-content {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            gap: 20px;
            min-height: 600px;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .sidebar, .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: linear-gradient(145deg, #3a3a3a 0%, #2a2a2a 100%);
            border: 2px solid #6b5539;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            position: relative;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, #8b4513 0%, #b8860b 50%, #8b4513 100%);
            border-radius: 8px 8px 0 0;
        }

        .card h3 {
            margin-bottom: 15px;
            color: #d4af37;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 8px;
            letter-spacing: 1px;
        }

        .upload-area {
            border: 2px dashed #8b6f47;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(139, 111, 71, 0.1);
        }

        .upload-area:hover {
            border-color: #b8860b;
            background: rgba(184, 134, 11, 0.15);
        }

        .upload-area.dragover {
            border-color: #d4af37;
            background: rgba(212, 175, 55, 0.2);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 10px;
            color: #cd853f;
        }

        input[type="file"] {
            display: none;
        }

        .file-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .file-item {
            padding: 10px;
            background: rgba(58, 58, 58, 0.5);
            border: 1px solid #6b5539;
            border-radius: 4px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-item:hover {
            background: rgba(139, 111, 71, 0.3);
            border-color: #b8860b;
        }

        .file-item.active {
            background: rgba(184, 134, 11, 0.3);
            border-color: #d4af37;
            font-weight: 600;
        }

        .file-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 0.9em;
            color: #c9b896;
        }

        .file-remove {
            color: #cd5c5c;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
            font-weight: bold;
        }

        .file-remove:hover {
            background: #8b4513;
            color: #f5e6d3;
        }

        .btn {
            padding: 12px 24px;
            border: 1px solid #5a4632;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s;
            display: inline-block;
            text-align: center;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-family: 'Georgia', 'Times New Roman', serif;
        }

        .btn-primary {
            background: linear-gradient(145deg, #8b6f47 0%, #6b5539 100%);
            color: #f5e6d3;
        }

        .btn-primary:hover:not(:disabled) {
            background: linear-gradient(145deg, #b8860b 0%, #8b6f47 100%);
            box-shadow: 0 4px 12px rgba(184, 134, 11, 0.4);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: linear-gradient(145deg, #4a4a4a 0%, #3a3a3a 100%);
            color: #c9b896;
        }

        .btn-secondary:hover:not(:disabled) {
            background: linear-gradient(145deg, #5a5a5a 0%, #4a4a4a 100%);
        }

        .btn-success {
            background: linear-gradient(145deg, #6b7f47 0%, #5a6b39 100%);
            color: #f5e6d3;
        }

        .btn-success:hover:not(:disabled) {
            background: linear-gradient(145deg, #7f9b47 0%, #6b7f39 100%);
            box-shadow: 0 4px 12px rgba(127, 155, 71, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-full {
            width: 100%;
            margin-bottom: 10px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-group label {
            cursor: pointer;
            user-select: none;
            font-weight: 500;
            color: #c9b896;
        }

        .select-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }

        .select-group label {
            font-weight: 600;
            color: #d4af37;
            font-size: 0.9em;
        }

        .select-group select {
            padding: 8px 12px;
            border: 1px solid #6b5539;
            border-radius: 4px;
            font-size: 1em;
            cursor: pointer;
            background: rgba(58, 58, 58, 0.5);
            color: #c9b896;
            font-family: 'Georgia', 'Times New Roman', serif;
        }

        .preview-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .preview-card {
            background: linear-gradient(145deg, #3a3a3a 0%, #2a2a2a 100%);
            border: 2px solid #6b5539;
            border-radius: 8px;
            padding: 15px;
            flex: 1;
        }

        .preview-card h4 {
            margin-bottom: 10px;
            color: #d4af37;
            font-size: 1em;
            letter-spacing: 1px;
        }

        .preview-canvas-container {
            background: #1a1a1a;
            border: 1px solid #6b5539;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            overflow: auto;
            position: relative;
        }

        .preview-canvas-container canvas {
            max-width: 100%;
            height: auto;
            display: block;
        }

        .preview-info {
            margin-top: 10px;
            font-size: 0.85em;
            color: #b8945f;
            display: flex;
            justify-content: space-between;
        }

        .navigation-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .status-bar {
            background: linear-gradient(145deg, #2a2a2a 0%, #1a1a1a 100%);
            border: 2px solid #6b5539;
            color: #c9b896;
            padding: 12px 30px;
            font-size: 0.9em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            border-radius: 4px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(107, 85, 57, 0.3);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #8b4513 0%, #b8860b 50%, #8b4513 100%);
            width: 0%;
            transition: width 0.3s;
        }

        .alert {
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 15px;
            border: 1px solid;
        }

        .alert-info {
            background: rgba(107, 134, 160, 0.2);
            color: #9db4c9;
            border-color: #6b86a0;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .back-link {
                position: static;
                display: block;
                margin-bottom: 20px;
                text-align: center;
            }
        }
    </style>
    <!-- Authentication Script -->
    <script src="auth.js"></script>
</head>
<body>
    <a href="index.html" class="back-link">‚Üê Back to Home</a>

    <div class="container">
        <div class="header">
            <h1>üìÑ PDF to TIFF Converter</h1>
            <p>Convert and clean engineering drawings for CAD ‚Ä¢ 100% Client-Side Processing</p>
        </div>

        <div class="main-content">
            <!-- Left Sidebar: File Management -->
            <div class="sidebar">
                <div class="card">
                    <h3>üìÅ Files</h3>
                    <div class="upload-area" id="uploadArea">
                        <div class="upload-icon">üì§</div>
                        <p><strong>Click or drag files here</strong></p>
                        <p style="font-size: 0.9em; color: #8b7355; margin-top: 5px;">PDF or TIFF files</p>
                    </div>
                    <input type="file" id="fileInput" accept=".pdf,.tif,.tiff" multiple>

                    <div class="btn-group" style="margin-top: 15px;">
                        <button class="btn btn-secondary" onclick="clearFiles()" style="flex: 1;">Clear All</button>
                    </div>

                    <div id="fileList" class="file-list"></div>
                </div>

                <div class="card">
                    <h3>‚ÑπÔ∏è File Info</h3>
                    <div id="fileInfo" style="font-size: 0.9em; color: #b8945f;">
                        <p>No file selected</p>
                    </div>
                </div>
            </div>

            <!-- Center: Preview -->
            <div class="preview-section">
                <div class="navigation-buttons">
                    <button class="btn btn-secondary" onclick="previousFile()" id="prevBtn" disabled>‚óÄ Previous</button>
                    <button class="btn btn-secondary" onclick="nextFile()" id="nextBtn" disabled>Next ‚ñ∂</button>
                    <button class="btn btn-primary" onclick="updatePreview()" id="previewBtn" disabled style="flex: 1;">üîÑ Update Preview</button>
                </div>

                <div class="preview-card">
                    <h4>Original Input</h4>
                    <div class="preview-canvas-container">
                        <canvas id="inputCanvas"></canvas>
                    </div>
                    <div class="preview-info">
                        <span id="inputInfo">-</span>
                    </div>
                </div>

                <div class="preview-card">
                    <h4>Processed Output</h4>
                    <div class="preview-canvas-container">
                        <canvas id="outputCanvas"></canvas>
                    </div>
                    <div class="preview-info">
                        <span id="outputInfo">-</span>
                    </div>
                </div>
            </div>

            <!-- Right Sidebar: Controls -->
            <div class="controls">
                <div class="card">
                    <h3>‚öôÔ∏è Processing Options</h3>

                    <div class="checkbox-group">
                        <input type="checkbox" id="convertPDF" checked>
                        <label for="convertPDF">PDF ‚Üí TIFF Convert</label>
                    </div>

                    <div class="alert alert-info" style="font-size: 0.85em;">
                        Converts PDF to 1-bit TIFF at 300 DPI with binarization
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="despeckle">
                        <label for="despeckle">Despeckle (Median Filter)</label>
                    </div>

                    <div class="select-group">
                        <label for="despeckleLevel">Kernel Size:</label>
                        <select id="despeckleLevel">
                            <option value="3">3√ó3 (Fast)</option>
                            <option value="5">5√ó5 (Balanced)</option>
                            <option value="7">7√ó7 (Strong)</option>
                        </select>
                    </div>

                    <div class="select-group">
                        <label for="targetDPI">Target DPI:</label>
                        <select id="targetDPI">
                            <option value="150">150 DPI</option>
                            <option value="200">200 DPI</option>
                            <option value="300" selected>300 DPI</option>
                            <option value="600">600 DPI</option>
                        </select>
                    </div>
                </div>

                <div class="card">
                    <h3>‚ñ∂Ô∏è Actions</h3>
                    <button class="btn btn-primary btn-full" onclick="processCurrentFile()" id="processBtn" disabled>
                        Process Current File
                    </button>
                    <button class="btn btn-success btn-full" onclick="processBatch()" id="batchBtn" disabled>
                        Process All Files
                    </button>
                    <div id="processingProgress" class="hidden">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <p style="text-align: center; margin-top: 8px; font-size: 0.9em;" id="progressText">0%</p>
                    </div>
                </div>

                <div class="card">
                    <h3>üí° Tips</h3>
                    <ul style="font-size: 0.85em; color: #b8945f; padding-left: 20px;">
                        <li style="margin-bottom: 8px;">Use keyboard arrows (‚Üê ‚Üí) to navigate files</li>
                        <li style="margin-bottom: 8px;">Despeckle removes noise from scanned images</li>
                        <li style="margin-bottom: 8px;">Binarization creates clean 1-bit output</li>
                        <li>All processing happens in your browser</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <span id="statusText">Ready ‚Ä¢ Load files to begin</span>
            <span id="statusCount">0 files</span>
        </div>
    </div>

    <!-- PDF.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <!-- UTIF.js for TIFF handling -->
    <script src="https://unpkg.com/utif@3.1.0/UTIF.js"></script>

    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Wait for UTIF to load
        if (typeof UTIF === 'undefined') {
            console.error('UTIF library failed to load');
        }

        // Application state
        let files = [];
        let currentIndex = 0;
        let currentInputImageData = null;
        let currentFileName = '';

        // Initialize event listeners
        document.getElementById('uploadArea').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });

        document.getElementById('fileInput').addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        // Drag and drop
        const uploadArea = document.getElementById('uploadArea');
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') previousFile();
            if (e.key === 'ArrowRight') nextFile();
        });

        // Auto-update preview when options change
        ['convertPDF', 'despeckle', 'despeckleLevel', 'targetDPI'].forEach(id => {
            const element = document.getElementById(id);
            if (element.type === 'checkbox') {
                element.addEventListener('change', () => updatePreview());
            } else {
                element.addEventListener('change', () => updatePreview());
            }
        });

        function handleFiles(fileList) {
            const newFiles = Array.from(fileList).filter(file => {
                const ext = file.name.toLowerCase();
                return ext.endsWith('.pdf') || ext.endsWith('.tif') || ext.endsWith('.tiff');
            });

            if (newFiles.length === 0) {
                alert('Please select PDF or TIFF files only');
                return;
            }

            files.push(...newFiles);
            updateFileList();
            if (files.length === 1) {
                currentIndex = 0;
                loadFile(0);
            }
            updateButtons();
            updateStatus();
        }

        function updateFileList() {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';

            files.forEach((file, index) => {
                const div = document.createElement('div');
                div.className = 'file-item' + (index === currentIndex ? ' active' : '');
                div.onclick = () => selectFile(index);

                const nameSpan = document.createElement('span');
                nameSpan.className = 'file-name';
                nameSpan.textContent = file.name;
                nameSpan.title = file.name;

                const removeSpan = document.createElement('span');
                removeSpan.className = 'file-remove';
                removeSpan.textContent = '√ó';
                removeSpan.onclick = (e) => {
                    e.stopPropagation();
                    removeFile(index);
                };

                div.appendChild(nameSpan);
                div.appendChild(removeSpan);
                fileList.appendChild(div);
            });
        }

        function selectFile(index) {
            if (index >= 0 && index < files.length) {
                currentIndex = index;
                loadFile(index);
                updateFileList();
            }
        }

        function removeFile(index) {
            files.splice(index, 1);
            if (currentIndex >= files.length) {
                currentIndex = Math.max(0, files.length - 1);
            }
            updateFileList();
            if (files.length > 0) {
                loadFile(currentIndex);
            } else {
                clearCanvas('inputCanvas');
                clearCanvas('outputCanvas');
                document.getElementById('fileInfo').innerHTML = '<p>No file selected</p>';
            }
            updateButtons();
            updateStatus();
        }

        function clearFiles() {
            if (files.length === 0) return;
            if (!confirm('Clear all files?')) return;

            files = [];
            currentIndex = 0;
            currentInputImageData = null;
            updateFileList();
            clearCanvas('inputCanvas');
            clearCanvas('outputCanvas');
            document.getElementById('fileInfo').innerHTML = '<p>No file selected</p>';
            document.getElementById('inputInfo').textContent = '-';
            document.getElementById('outputInfo').textContent = '-';
            updateButtons();
            updateStatus();
        }

        function previousFile() {
            if (files.length === 0) return;
            currentIndex = (currentIndex - 1 + files.length) % files.length;
            loadFile(currentIndex);
            updateFileList();
        }

        function nextFile() {
            if (files.length === 0) return;
            currentIndex = (currentIndex + 1) % files.length;
            loadFile(currentIndex);
            updateFileList();
        }

        async function loadFile(index) {
            const file = files[index];
            currentFileName = file.name;

            document.getElementById('statusText').textContent = `Loading ${file.name}...`;

            try {
                const isPDF = file.name.toLowerCase().endsWith('.pdf');
                const isTIFF = file.name.toLowerCase().endsWith('.tif') || file.name.toLowerCase().endsWith('.tiff');

                if (isPDF) {
                    await loadPDF(file);
                    document.getElementById('convertPDF').disabled = false;
                } else if (isTIFF) {
                    await loadTIFF(file);
                    document.getElementById('convertPDF').disabled = true;
                    document.getElementById('convertPDF').checked = false;
                }

                updateFileInfo(file, isPDF, isTIFF);
                await updatePreview();

            } catch (error) {
                console.error('Error loading file:', error);
                alert(`Error loading ${file.name}: ${error.message}`);
            }
        }

        async function loadPDF(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
            const page = await pdf.getPage(1);

            const targetDPI = parseInt(document.getElementById('targetDPI').value);
            const scale = targetDPI / 72;
            const viewport = page.getViewport({scale: scale});

            const canvas = document.createElement('canvas');
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            const context = canvas.getContext('2d');

            await page.render({
                canvasContext: context,
                viewport: viewport
            }).promise;

            currentInputImageData = context.getImageData(0, 0, canvas.width, canvas.height);

            // Display on input canvas
            const inputCanvas = document.getElementById('inputCanvas');
            inputCanvas.width = canvas.width;
            inputCanvas.height = canvas.height;
            inputCanvas.getContext('2d').putImageData(currentInputImageData, 0, 0);

            document.getElementById('inputInfo').textContent =
                `${canvas.width} √ó ${canvas.height} px @ ${targetDPI} DPI`;
        }

        async function loadTIFF(file) {
            const arrayBuffer = await file.arrayBuffer();
            const ifds = UTIF.decode(arrayBuffer);
            UTIF.decodeImage(arrayBuffer, ifds[0]);
            const rgba = UTIF.toRGBA8(ifds[0]);

            const canvas = document.createElement('canvas');
            canvas.width = ifds[0].width;
            canvas.height = ifds[0].height;
            const context = canvas.getContext('2d');

            const imageData = context.createImageData(canvas.width, canvas.height);
            imageData.data.set(new Uint8ClampedArray(rgba));
            context.putImageData(imageData, 0, 0);

            currentInputImageData = imageData;

            // Display on input canvas
            const inputCanvas = document.getElementById('inputCanvas');
            inputCanvas.width = canvas.width;
            inputCanvas.height = canvas.height;
            inputCanvas.getContext('2d').putImageData(currentInputImageData, 0, 0);

            const dpi = ifds[0].t282 ? ifds[0].t282[0] : 300;
            document.getElementById('inputInfo').textContent =
                `${canvas.width} √ó ${canvas.height} px @ ${Math.round(dpi)} DPI`;
        }

        function updateFileInfo(file, isPDF, isTIFF) {
            const size = (file.size / 1024).toFixed(1);
            const type = isPDF ? 'PDF Document' : isTIFF ? 'TIFF Image' : 'Unknown';

            document.getElementById('fileInfo').innerHTML = `
                <p><strong>Name:</strong> ${file.name}</p>
                <p><strong>Type:</strong> ${type}</p>
                <p><strong>Size:</strong> ${size} KB</p>
                <p><strong>Modified:</strong> ${file.lastModifiedDate.toLocaleDateString()}</p>
            `;
        }

        async function updatePreview() {
            if (!currentInputImageData) return;

            const isPDF = currentFileName.toLowerCase().endsWith('.pdf');
            const convertPDF = document.getElementById('convertPDF').checked;
            const despeckle = document.getElementById('despeckle').checked;
            const despeckleLevel = parseInt(document.getElementById('despeckleLevel').value);

            let imageData = cloneImageData(currentInputImageData);

            // Apply despeckle
            if (despeckle) {
                imageData = medianFilter(imageData, despeckleLevel);
            }

            // Apply binarization for PDF conversion
            if (isPDF && convertPDF) {
                imageData = toBilevel(imageData);
            }

            // Display output
            const outputCanvas = document.getElementById('outputCanvas');
            outputCanvas.width = imageData.width;
            outputCanvas.height = imageData.height;
            outputCanvas.getContext('2d').putImageData(imageData, 0, 0);

            const mode = (isPDF && convertPDF) ? '1-bit (bilevel)' : '8-bit grayscale';
            document.getElementById('outputInfo').textContent =
                `${imageData.width} √ó ${imageData.height} px ‚Ä¢ ${mode}`;

            document.getElementById('statusText').textContent =
                `Preview updated: ${currentFileName} (${currentIndex + 1}/${files.length})`;
        }

        function cloneImageData(imageData) {
            const newData = new ImageData(imageData.width, imageData.height);
            newData.data.set(imageData.data);
            return newData;
        }

        function medianFilter(imageData, kernel) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            const output = new ImageData(width, height);
            const outData = output.data;

            const halfKernel = Math.floor(kernel / 2);
            const window = [];

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    window.length = 0;

                    // Collect window values (using grayscale)
                    for (let ky = -halfKernel; ky <= halfKernel; ky++) {
                        for (let kx = -halfKernel; kx <= halfKernel; kx++) {
                            const px = Math.min(Math.max(x + kx, 0), width - 1);
                            const py = Math.min(Math.max(y + ky, 0), height - 1);
                            const idx = (py * width + px) * 4;
                            const gray = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                            window.push(gray);
                        }
                    }

                    // Sort and get median
                    window.sort((a, b) => a - b);
                    const median = window[Math.floor(window.length / 2)];

                    const idx = (y * width + x) * 4;
                    outData[idx] = median;
                    outData[idx + 1] = median;
                    outData[idx + 2] = median;
                    outData[idx + 3] = 255;
                }
            }

            return output;
        }

        function toBilevel(imageData) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;

            // Convert to grayscale array
            const gray = new Uint8Array(width * height);
            for (let i = 0; i < width * height; i++) {
                const idx = i * 4;
                gray[i] = Math.round((data[idx] + data[idx + 1] + data[idx + 2]) / 3);
            }

            // Otsu's method
            const threshold = otsuThreshold(gray);

            // Apply threshold
            const output = new ImageData(width, height);
            const outData = output.data;

            for (let i = 0; i < width * height; i++) {
                const value = gray[i] > threshold ? 255 : 0;
                const idx = i * 4;
                outData[idx] = value;
                outData[idx + 1] = value;
                outData[idx + 2] = value;
                outData[idx + 3] = 255;
            }

            return output;
        }

        function otsuThreshold(grayArray) {
            const histogram = new Array(256).fill(0);
            const total = grayArray.length;

            // Build histogram
            for (let i = 0; i < total; i++) {
                histogram[grayArray[i]]++;
            }

            let sum = 0;
            for (let i = 0; i < 256; i++) {
                sum += i * histogram[i];
            }

            let sumB = 0;
            let wB = 0;
            let wF = 0;
            let maxVariance = 0;
            let threshold = 0;

            for (let t = 0; t < 256; t++) {
                wB += histogram[t];
                if (wB === 0) continue;

                wF = total - wB;
                if (wF === 0) break;

                sumB += t * histogram[t];
                const mB = sumB / wB;
                const mF = (sum - sumB) / wF;

                const variance = wB * wF * (mB - mF) * (mB - mF);

                if (variance > maxVariance) {
                    maxVariance = variance;
                    threshold = t;
                }
            }

            return threshold;
        }

        async function processCurrentFile() {
            if (!currentInputImageData) {
                alert('No file loaded');
                return;
            }

            document.getElementById('processBtn').disabled = true;
            document.getElementById('statusText').textContent = 'Processing...';

            try {
                const result = await processImage(currentInputImageData, currentFileName);
                downloadFile(result.blob, result.filename);
                document.getElementById('statusText').textContent = `‚úì Processed: ${result.filename}`;
            } catch (error) {
                console.error('Processing error:', error);
                alert(`Error processing file: ${error.message}`);
                document.getElementById('statusText').textContent = 'Error during processing';
            }

            document.getElementById('processBtn').disabled = false;
        }

        async function processBatch() {
            if (files.length === 0) {
                alert('No files to process');
                return;
            }

            if (!confirm(`Process all ${files.length} files?`)) return;

            document.getElementById('batchBtn').disabled = true;
            document.getElementById('processBtn').disabled = true;
            document.getElementById('processingProgress').classList.remove('hidden');

            const results = [];

            for (let i = 0; i < files.length; i++) {
                const progress = ((i + 1) / files.length) * 100;
                document.getElementById('progressFill').style.width = `${progress}%`;
                document.getElementById('progressText').textContent = `${Math.round(progress)}%`;
                document.getElementById('statusText').textContent = `Processing ${i + 1}/${files.length}: ${files[i].name}`;

                try {
                    // Load file
                    currentIndex = i;
                    await loadFile(i);

                    // Process
                    const result = await processImage(currentInputImageData, files[i].name);
                    results.push(result);

                    // Small delay to allow UI updates
                    await new Promise(resolve => setTimeout(resolve, 100));
                } catch (error) {
                    console.error(`Error processing ${files[i].name}:`, error);
                }
            }

            // Download files individually
            for (const result of results) {
                await downloadFile(result.blob, result.filename);
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            document.getElementById('processingProgress').classList.add('hidden');
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('batchBtn').disabled = false;
            document.getElementById('processBtn').disabled = false;
            document.getElementById('statusText').textContent = `‚úì Completed ${results.length} files`;

            alert(`Successfully processed ${results.length} out of ${files.length} files`);
        }

        async function processImage(imageData, filename) {
            const isPDF = filename.toLowerCase().endsWith('.pdf');
            const convertPDF = document.getElementById('convertPDF').checked;
            const despeckle = document.getElementById('despeckle').checked;
            const despeckleLevel = parseInt(document.getElementById('despeckleLevel').value);
            const targetDPI = parseInt(document.getElementById('targetDPI').value);

            let processedData = cloneImageData(imageData);

            // Apply despeckle
            if (despeckle) {
                processedData = medianFilter(processedData, despeckleLevel);
            }

            // Apply binarization for PDF conversion
            if (isPDF && convertPDF) {
                processedData = toBilevel(processedData);
            }

            // Convert to canvas
            const canvas = document.createElement('canvas');
            canvas.width = processedData.width;
            canvas.height = processedData.height;
            canvas.getContext('2d').putImageData(processedData, 0, 0);

            // Create TIFF blob
            const blob = await canvasToTIFF(canvas, targetDPI);

            const baseName = filename.substring(0, filename.lastIndexOf('.'));
            const suffix = (isPDF && convertPDF) ? '_300dpi_bin' : (despeckle ? '_despeckle' : '_processed');
            const outputFilename = `${baseName}${suffix}.tif`;

            return { blob: blob, filename: outputFilename };
        }

        async function canvasToTIFF(canvas, dpi) {
            // Get image data from canvas
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const width = canvas.width;
            const height = canvas.height;

            // Check if image is bilevel (only black and white pixels)
            let isBilevel = true;
            for (let i = 0; i < imageData.data.length; i += 4) {
                const r = imageData.data[i];
                const g = imageData.data[i + 1];
                const b = imageData.data[i + 2];
                // Check if pixel is pure black (0,0,0) or pure white (255,255,255)
                if (!((r === 0 && g === 0 && b === 0) || (r === 255 && g === 255 && b === 255))) {
                    isBilevel = false;
                    break;
                }
            }

            let data, ifd;

            if (isBilevel) {
                // Encode as 1-bit bilevel (black and white only)
                // Pack 8 pixels into 1 byte
                const bytesPerRow = Math.ceil(width / 8);
                const bilevelData = new Uint8Array(bytesPerRow * height);

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        const isWhite = imageData.data[idx] === 255;

                        if (isWhite) {
                            const byteIdx = y * bytesPerRow + Math.floor(x / 8);
                            const bitIdx = 7 - (x % 8);
                            bilevelData[byteIdx] |= (1 << bitIdx);
                        }
                    }
                }

                data = bilevelData;
                ifd = {
                    t256: [width],              // ImageWidth
                    t257: [height],             // ImageLength
                    t258: [1],                  // BitsPerSample (1 bit)
                    t259: [1],                  // Compression (1 = none)
                    t262: [1],                  // PhotometricInterpretation (1 = BlackIsZero)
                    t277: [1],                  // SamplesPerPixel (1 for bilevel)
                    t278: [height],             // RowsPerStrip
                    t282: [dpi, 1],            // XResolution
                    t283: [dpi, 1],            // YResolution
                    t284: [1],                  // PlanarConfiguration
                    t296: [2]                   // ResolutionUnit (inches)
                };
            } else {
                // Encode as 8-bit grayscale (much smaller than RGB)
                const grayData = new Uint8Array(width * height);

                for (let i = 0; i < width * height; i++) {
                    const r = imageData.data[i * 4];
                    const g = imageData.data[i * 4 + 1];
                    const b = imageData.data[i * 4 + 2];
                    // Convert to grayscale
                    grayData[i] = Math.round((r + g + b) / 3);
                }

                data = grayData;
                ifd = {
                    t256: [width],              // ImageWidth
                    t257: [height],             // ImageLength
                    t258: [8],                  // BitsPerSample (8-bit grayscale)
                    t259: [1],                  // Compression (1 = none)
                    t262: [1],                  // PhotometricInterpretation (1 = BlackIsZero)
                    t277: [1],                  // SamplesPerPixel (1 for grayscale)
                    t278: [height],             // RowsPerStrip
                    t282: [dpi, 1],            // XResolution
                    t283: [dpi, 1],            // YResolution
                    t284: [1],                  // PlanarConfiguration
                    t296: [2]                   // ResolutionUnit (inches)
                };
            }

            // Use UTIF.encodeImage to create TIFF
            try {
                const tiffData = UTIF.encodeImage(data.buffer, width, height, ifd);
                return new Blob([tiffData], { type: 'image/tiff' });
            } catch (error) {
                console.error('TIFF encoding error:', error);
                console.error('IFD:', ifd);
                console.error('Data length:', data.length);
                // Fallback to PNG if TIFF encoding fails
                return new Promise((resolve) => {
                    canvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/png');
                });
            }
        }

        function downloadFile(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function clearCanvas(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvas.width = 0;
            canvas.height = 0;
        }

        function updateButtons() {
            const hasFiles = files.length > 0;
            document.getElementById('prevBtn').disabled = !hasFiles;
            document.getElementById('nextBtn').disabled = !hasFiles;
            document.getElementById('previewBtn').disabled = !hasFiles;
            document.getElementById('processBtn').disabled = !hasFiles;
            document.getElementById('batchBtn').disabled = !hasFiles;
        }

        function updateStatus() {
            document.getElementById('statusCount').textContent = `${files.length} file${files.length !== 1 ? 's' : ''}`;
            if (files.length === 0) {
                document.getElementById('statusText').textContent = 'Ready ‚Ä¢ Load files to begin';
            }
        }

        // Initialize
        updateButtons();
        updateStatus();
    </script>
</body>
</html>
